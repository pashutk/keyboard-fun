<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Keyboard Fun</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #F5E6A3;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    font-family: 'Comic Sans MS', cursive, system-ui;
    transition: background-color 0.15s ease;
  }

  body.shake {
    animation: shake 80ms ease-in-out;
  }

  #text-area {
    position: relative;
    z-index: 1;
    padding: 40px;
    height: 100vh;
    overflow-y: auto;
    overflow-x: hidden;
    display: flex;
    flex-wrap: wrap;
    align-content: flex-start;
    gap: 0;
    scrollbar-width: none;
  }
  #text-area::-webkit-scrollbar { display: none; }

  .line {
    display: flex;
    flex-wrap: wrap;
    width: 100%;
    min-height: 1.2em;
    align-items: baseline;
  }

  .letter {
    display: inline-block;
    font-size: 400px;
    font-weight: bold;
    animation: bounce-in 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.15), 0 0 10px rgba(255,255,255,0.5);
    transform-origin: center bottom;
    transform: scale(0);
  }

  .letter.idle {
    transform: scale(1);
    animation: jelly-float 3s ease-in-out infinite;
    animation-delay: var(--jelly-delay, 0s);
  }

  .letter.nudged {
    transform: scale(1);
    animation: nudge 0.4s ease-out;
  }

  .letter.space {
    width: 0.4em;
  }

  .letter.poof {
    animation: poof 0.35s ease-in forwards !important;
  }

  .letter.shatter {
    animation: shatter 0.6s ease-in forwards !important;
  }

  #cursor {
    display: inline-block;
    width: 3px;
    height: 400px;
    background: #333;
    animation: blink 0.7s step-end infinite;
    vertical-align: baseline;
    margin-left: 2px;
    align-self: center;
  }

  canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 2;
    pointer-events: none;
  }

  .wave-ring {
    position: fixed;
    border: 4px solid rgba(255, 100, 50, 0.7);
    border-radius: 50%;
    pointer-events: none;
    z-index: 3;
    animation: wave-ring 0.7s ease-out forwards;
  }

  @keyframes bounce-in {
    0%   { transform: scale(0) rotate(0deg); }
    50%  { transform: scale(1.3) rotate(-3deg); }
    70%  { transform: scale(0.9) rotate(2deg); }
    85%  { transform: scale(1.05) rotate(-1deg); }
    100% { transform: scale(1) rotate(0deg); }
  }

  @keyframes jelly-float {
    0%, 100% { transform: scale(1) rotate(0deg) translateY(0); }
    25%  { transform: scale(1.02, 0.98) rotate(0.5deg) translateY(-2px); }
    50%  { transform: scale(0.98, 1.02) rotate(-0.5deg) translateY(1px); }
    75%  { transform: scale(1.01, 0.99) rotate(0.3deg) translateY(-1px); }
  }

  @keyframes nudge {
    0%   { transform: scale(1) rotate(0deg); }
    30%  { transform: scale(1.1, 0.9) rotate(var(--nudge-dir, 3deg)); }
    60%  { transform: scale(0.95, 1.05) rotate(calc(var(--nudge-dir, 3deg) * -0.5)); }
    100% { transform: scale(1) rotate(0deg); }
  }

  @keyframes shake {
    0%, 100% { transform: translate(0, 0); }
    20%      { transform: translate(-4px, 2px); }
    40%      { transform: translate(3px, -3px); }
    60%      { transform: translate(-2px, 4px); }
    80%      { transform: translate(4px, -1px); }
  }

  @keyframes poof {
    0%   { transform: scale(1) rotate(0deg); opacity: 1; }
    100% { transform: scale(0) rotate(360deg); opacity: 0; }
  }

  @keyframes shatter {
    0%   { transform: translate(0, 0) rotate(0deg) scale(1); opacity: 1; }
    100% {
      transform: translate(var(--sx), var(--sy)) rotate(var(--sr)) scale(0);
      opacity: 0;
    }
  }

  @keyframes wave-ring {
    0%   { width: 10px; height: 10px; opacity: 1; border-width: 4px; }
    100% { width: 300px; height: 300px; opacity: 0; border-width: 1px; }
  }

  @keyframes blink {
    0%, 100% { opacity: 1; }
    50%      { opacity: 0; }
  }
</style>
</head>
<body>
<div id="text-area">
  <div class="line" id="current-line">
    <span id="cursor"></span>
  </div>
</div>
<canvas id="canvas"></canvas>

<script>
// Prevent accidental page close â€” user can still close via mouse
window.addEventListener('beforeunload', (e) => {
  e.preventDefault();
});

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const textArea = document.getElementById('text-area');
let currentLine = document.getElementById('current-line');
const cursor = document.getElementById('cursor');

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

const BRIGHT_COLORS = [
  '#FF1744', '#F50057', '#D500F9', '#651FFF',
  '#2979FF', '#00B0FF', '#00E5FF', '#1DE9B6',
  '#00E676', '#76FF03', '#FFEA00', '#FF9100',
  '#FF3D00', '#FF6D00', '#FF1493', '#00CED1',
  '#FF4500', '#32CD32', '#8A2BE2', '#FF69B4',
];

function randomColor() {
  return BRIGHT_COLORS[Math.floor(Math.random() * BRIGHT_COLORS.length)];
}

// --- Particle System ---
const particles = [];

function spawnParticles(x, y, count, opts = {}) {
  const {
    speedMin = 2, speedMax = 7,
    sizeMin = 3, sizeMax = 8,
    gravity = 0.15,
    life = 1,
    confetti = false,
    implode = false,
    trail = false,
  } = opts;

  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = speedMin + Math.random() * (speedMax - speedMin);
    const dir = implode ? -1 : 1;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed * dir,
      vy: Math.sin(angle) * speed * dir - (confetti ? 0 : trail ? 0.5 : 1),
      size: sizeMin + Math.random() * (sizeMax - sizeMin),
      color: opts.color || randomColor(),
      life: life,
      maxLife: life,
      gravity: gravity,
      shape: confetti ? 'rect' : trail ? 'circle' : (Math.random() > 0.5 ? 'circle' : 'square'),
      rotation: Math.random() * Math.PI * 2,
      rotSpeed: confetti ? (Math.random() - 0.5) * 0.2 : 0,
      confetti: confetti,
    });
  }
}

function updateAndDrawParticles() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += p.gravity;
    p.life -= 0.016;
    p.rotation += p.rotSpeed;

    if (p.life <= 0) {
      particles.splice(i, 1);
      continue;
    }

    const alpha = Math.max(0, p.life / p.maxLife);
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    ctx.translate(p.x, p.y);
    ctx.rotate(p.rotation);

    if (p.confetti) {
      ctx.fillRect(-p.size / 2, -p.size, p.size, p.size * 2.5);
    } else if (p.shape === 'circle') {
      ctx.beginPath();
      ctx.arc(0, 0, p.size, 0, Math.PI * 2);
      ctx.fill();
    } else {
      ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
    }

    ctx.restore();
  }

  requestAnimationFrame(updateAndDrawParticles);
}
updateAndDrawParticles();

// --- Letter physics: set idle wobble after bounce-in ---
function makeIdle(span) {
  span.addEventListener('animationend', function handler() {
    if (span.classList.contains('poof') || span.classList.contains('shatter')) return;
    span.classList.remove('nudged');
    span.classList.add('idle');
    span.removeEventListener('animationend', handler);
  }, { once: true });
}

// --- Nudge nearby letters when a new one lands ---
function nudgeNeighbors(newSpan) {
  const allLetters = currentLine.querySelectorAll('.letter.idle');
  if (allLetters.length === 0) return;

  const newRect = newSpan.getBoundingClientRect();
  const newCx = newRect.left + newRect.width / 2;

  allLetters.forEach(letter => {
    const rect = letter.getBoundingClientRect();
    const cx = rect.left + rect.width / 2;
    const dist = Math.abs(newCx - cx);

    if (dist < 600) {
      const dir = cx < newCx ? '-4deg' : '4deg';
      letter.style.setProperty('--nudge-dir', dir);
      letter.classList.remove('idle', 'nudged');
      void letter.offsetWidth;
      letter.classList.add('nudged');
      letter.addEventListener('animationend', () => {
        letter.classList.remove('nudged');
        letter.classList.add('idle');
      }, { once: true });
    }
  });
}

// --- Screen shake ---
function screenShake() {
  document.body.classList.remove('shake');
  void document.body.offsetWidth;
  document.body.classList.add('shake');
  setTimeout(() => document.body.classList.remove('shake'), 100);
}

// --- Background flash ---
function bgFlash() {
  const hueShift = Math.floor(Math.random() * 10) - 5;
  document.body.style.backgroundColor = `hsl(${48 + hueShift}, 55%, 80%)`;
  setTimeout(() => { document.body.style.backgroundColor = '#F5E6A3'; }, 150);
}

// --- Wave ring (space) ---
function waveRing(x, y) {
  const ring = document.createElement('div');
  ring.className = 'wave-ring';
  ring.style.left = (x - 5) + 'px';
  ring.style.top = (y - 5) + 'px';
  document.body.appendChild(ring);
  ring.addEventListener('animationend', () => ring.remove());
}

// --- Get position of last letter or cursor ---
function getInsertPosition() {
  const rect = cursor.getBoundingClientRect();
  return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
}

// --- Scroll cursor into view ---
function scrollToView() {
  cursor.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
}

// --- Key handling ---
// Capture ALL keyboard events to prevent browser shortcuts like Cmd+W
document.addEventListener('keydown', (e) => {
  e.preventDefault();

  // Ignore modifier-only keys
  if (['Shift', 'Control', 'Alt', 'Meta', 'CapsLock', 'Tab'].includes(e.key)) return;

  // If modifier keys held (except Shift), treat the combo as a fun character
  const hasModifier = e.ctrlKey || e.metaKey || e.altKey;

  if (e.key === 'Escape') {
    handleEscape();
    return;
  }

  if (e.key === 'Backspace') {
    handleBackspace();
    scrollToView();
    return;
  }

  if (e.key === 'Enter') {
    handleEnter();
    scrollToView();
    return;
  }

  if (e.key === ' ') {
    handleSpace();
    scrollToView();
    return;
  }

  // Printable character
  if (e.key.length === 1) {
    handleCharacter(e.key);
    scrollToView();
  }
});

function handleCharacter(char) {
  const span = document.createElement('span');
  span.className = 'letter';
  span.textContent = char;
  span.style.color = randomColor();
  span.style.setProperty('--jelly-delay', (Math.random() * 2).toFixed(2) + 's');
  currentLine.insertBefore(span, cursor);

  makeIdle(span);

  screenShake();
  bgFlash();

  // Particle burst at letter position + nudge neighbors
  requestAnimationFrame(() => {
    const rect = span.getBoundingClientRect();
    const cx = rect.left + rect.width / 2;
    const cy = rect.top + rect.height / 2;
    spawnParticles(cx, cy, 15 + Math.floor(Math.random() * 11));
    nudgeNeighbors(span);
  });
}

function handleSpace() {
  const span = document.createElement('span');
  span.className = 'letter space';
  span.innerHTML = '&nbsp;';
  currentLine.insertBefore(span, cursor);

  const pos = getInsertPosition();
  waveRing(pos.x, pos.y);
  spawnParticles(pos.x, pos.y, 10, { speedMin: 1, speedMax: 4, sizeMin: 2, sizeMax: 5, life: 0.6 });
}

function handleEnter() {
  cursor.remove();

  const newLine = document.createElement('div');
  newLine.className = 'line';
  newLine.appendChild(cursor);
  textArea.appendChild(newLine);
  currentLine = newLine;

  for (let i = 0; i < 120; i++) {
    const x = Math.random() * canvas.width;
    spawnParticles(x, -10, 1, {
      speedMin: 1, speedMax: 4,
      sizeMin: 4, sizeMax: 8,
      gravity: 0.08,
      life: 1.5 + Math.random(),
      confetti: true,
    });
  }

  screenShake();
}

function handleBackspace() {
  const letters = currentLine.querySelectorAll('.letter');
  if (letters.length === 0) {
    const lines = textArea.querySelectorAll('.line');
    if (lines.length > 1) {
      currentLine.remove();
      currentLine = lines[lines.length - 2];
      currentLine.appendChild(cursor);
    }
    return;
  }

  const lastLetter = letters[letters.length - 1];
  const rect = lastLetter.getBoundingClientRect();
  const cx = rect.left + rect.width / 2;
  const cy = rect.top + rect.height / 2;

  lastLetter.classList.remove('idle', 'nudged');
  lastLetter.classList.add('poof');
  lastLetter.addEventListener('animationend', () => lastLetter.remove());

  spawnParticles(cx, cy, 12, {
    speedMin: 1, speedMax: 4,
    sizeMin: 2, sizeMax: 5,
    gravity: 0.05,
    life: 0.5,
    implode: true,
  });
}

function handleEscape() {
  const allLetters = textArea.querySelectorAll('.letter');
  if (allLetters.length === 0) return;

  allLetters.forEach(letter => {
    const sx = (Math.random() - 0.5) * 600 + 'px';
    const sy = (Math.random() - 0.5) * 600 + 'px';
    const sr = (Math.random() - 0.5) * 720 + 'deg';
    letter.style.setProperty('--sx', sx);
    letter.style.setProperty('--sy', sy);
    letter.style.setProperty('--sr', sr);
    letter.classList.remove('idle', 'nudged');
    letter.classList.add('shatter');
  });

  for (let i = 0; i < 60; i++) {
    spawnParticles(
      Math.random() * canvas.width,
      Math.random() * canvas.height,
      1,
      { speedMin: 3, speedMax: 8, sizeMin: 3, sizeMax: 7, life: 0.8 }
    );
  }

  screenShake();

  setTimeout(() => {
    textArea.innerHTML = '';
    const newLine = document.createElement('div');
    newLine.className = 'line';
    newLine.id = 'current-line';
    newLine.appendChild(cursor);
    textArea.appendChild(newLine);
    currentLine = newLine;
  }, 650);
}
</script>
</body>
</html>
